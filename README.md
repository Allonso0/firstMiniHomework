# Домашнее задание №1. Закрепление принципов SOLID, внедрения зависимостей средствами DI-контейнера.
___
## Идеи моего решения

- В общем и целом, я реализовал все, что предлагалось в условии задания. Полет фантазии позволил себе в плане добавлении животного. После выбора данной опции пользователь должен с помощью предложенных обозначений ввести информацию о животном (тип животного, вид животного, имя, потребление еды и уровень здоровья (по шкале от 1 до 10. Если этот уровень >= 8, то животное добавляется в зоопарк), а также, для травоядных, уровень доброты).
- Что касается ID. В условии четко не прописано, как должны присваиваться номера, так что я решил нумеровать все объекты (и вещи, и животных) по порядку (от 1 и далее). Для этого был создан класс, который генерирует внутри себя айди и который наследуется животными и вещами.

#### Расположение файлов
- Все созданные мною классы находятся в папке ***classes***. У каждого класса присутствуют комментарии, поясняющие его функционал. Все классы отвечают требованиям SOLID, но об этом чуть позже. Также, говоря про классы, я реализовал все предложенные по условию классы, добавил между ними необходимые зависимости. Я создал дополнительные классы для делегирования обязанностей с класса Zoo, чтобы он удовлетворял принципу единственной ответственности.
- Созданные мною функции находятся в папке ***functions***. У них также присутствуют комментарии, но, если кратко, то они созданы для реализации ввода пользователем данных о животном для его последующего добавления (**AnimalAdding.kt**), отображения на экране списков всех вещей на балансе зоопарка и списка жвиотных для отправки в контактный зоопарк (**ListDisplaying.kt**), а также для вывода экранного меню и для реализации ввода пользователем данных о добавляемой вещи (**ThingAdding.kt**).
- Созданные мною интерфейсы находятся в папке ***interfaces***. Комментарии также присутствуют. Помимо заданных в условии интерфейсов я добавил интерфейсы **CоntactZooChecker** и **IThingFactory** для определения логики проверки животного на соответсвие критериям добавления в контактный зоопарк и для определения фабричного метода для создания вещей соответственно.

#### Почему соблюдается SOLID и как я применил DI

**1. Single Responsibility Principle**

Все созданные мною классы решают одну конкретную задачу. Единственное что, есть сомнения по поводу класса Zoo, но я считаю, что его единственной задачей является координация работ других компонентов и я уже упростил его логику достаточно сильно (до этого он занимался всеми вещами, что делают inventoryManager, foodCalculator и contactZooChecker).

**2. Open/Closed Principle**

Программные сущности открыты для расширения, но закрыты для изменения. Формально это значит, что можно добавлять новую функциональность без необходимости менять уже написанный код. Это достигается благодаря абстракциям (можно добавлять новых животных без изменения кода). Если нужно поменять, к примеру, критерии отбора животных в контактный зоопарк, то можно просто расширить реализацию интерфейса IContactZooChecker.

**3. Liskov Substitution Principle**

Все подклассы корректно реализуют поведение базовых классов.

**4.Interface Segregation Principle**

Интерфейсы не разросшиеся и не содержат избыточных методов.

**5.Dependency Inversion Principle**

Все зависимости я внедряю через DI-контейнер Koin. Для этого я использую appModule, где в одном месте собраны все зависимости. Они создаются тогда, когда нужны (ленивая инициализация) и для того, чтобы заменить реализацию какой-либо зависимости достаточно поменять ее в appModule.

___
## Инструкция по запуску

- Я писал программу на языке программирования Kotlin в IntellijIDEA. 
- Запускал программу с помощью обычного сочетания клавиш **Shift + F10**. 

Таким способом всё успешно запускается и корректно отображается в консоли.
Изначально пользователю выводится экранное меню, содержащее 6 опций:
1. Добавить животное
2. Добавить вещь
3. Получить отчет по еде
4. Получить список животных, подходящих для контактного зоопарка
5. Получить список всех животных/вещей на балансе зоопарка
6. Выход

Далее пользователь может взаимодействовать с программой при помощи этого меню, вводя в консоль допустимые значения. При некорректном вводе заново открывается экранное меню, экстренного завершения не происходит.

*Чтобы закрыть экранное меню, надо ввести в консоль цифру **6**.*

___

Фух, очень долго это всё прописывал. Хотел ещё отметить одну вещь, я изначально хотел и пытался сделать юнит-тесты для программы. Но возникла проблема с моками, так что не получилось реализовать эту часть. Я бы с радостью повозился с этим и реализовал полное покрытие юнит-тестами, но слишком уж много сторонних дел (в том числе курсовая работа, которую я тоже делаю на Kotlin в Android Studio. Так что с юнит-тестами я еще встречусь)

### Поздравляю с завершением чтения этой стены текста! Кто бы Вы не были, Вы - герой!
